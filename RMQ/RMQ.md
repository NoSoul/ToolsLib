# RMQ(Range Minimum/Maximum Query)
## Sparse Table算法
### 定义
* Dp[i][j]表示[i,i+2^j-1]这个区间的最值

当询问[a,b]区间的最值时，只需要考虑Minimum/Maximum{Dp[a,k]，Dp[b-2^k+1,k]}，其中2^k<=b-a+1，k=ln(b-a+1)/ln(2)
### 状态转移公式
* Dp[i][0]=A[i]
* Dp[i][j]=Minimum/Maximum{Dp[i,j-1], Dp[i+2^(j-1),j-1]}，其中[i,i+2^j-1]等分为[i,i+2^(j-1)-1]和[i+2^(j-1),i+2^j-1]

构造的复杂度为O(N*log(N))，查询的复杂度O(1)
## 笛卡尔树
### 定义
* 结点与数列元素一一对应
* 中序遍历笛卡尔树的结果就是原数列
* 笛卡尔树存在堆性质

### 树的构建
如果遍历原数列进行插入的顺序为0,1,2...N-1，根据定义二，每次插入新节点都为新树的右链的最后一个元素，因此辅助栈保存的是笛卡尔树的右链，则栈底为笛卡尔书的根节点，栈顶为笛卡尔树的右链的最后一元素。

设堆的性质为最大堆，当新节点需要被插入时: 

* 从栈顶开始遍历，由于是最大堆，找出比新节点大的元素
* 如果在栈中找到比新节点大的元素，将新节点的父节点更新为找到的节点
* 将所有比新节点小的元素组成的链更新为新节点的左子树的右链
* 更新栈顶元素为新节点

因为每个元素从栈中移除的次数为1次，构造的复杂度为O(N)
## 约束RMQ
### 定义
* 相邻元素差的绝对值为1

### 转化为约束RMQ
在已有的笛卡尔树上，任意两个节点u和v的LCA就是在从树根开始深度优先搜索中，u和v之间到达的节点中层数最小的那一个

* 设E[2*N-1]为深度优先搜索中每一步的节点
* 设L[2*N-1]为E中的每一步节点对应在树中的层数
* 设H[N]为每个节点第一次在L中出现的位置

则对任意的u和v，LCA(u, v)等价于在L中找到H[u]和H[v]之间最小值的下标i，则LCA(u, v)=E[i]，构造的复杂度仍为O(N)
## 约束RMQ的解法
此时|L[i]-L[i-1]|=1 (i=1,2...N-1)

* 将L分解为长度为l=log(N)/2的块，设B[i]为第i块的最小值，使用ST算法处理B数组的复杂度为O(N/l\*log(N/l))=O(N/l\*(log(N)-log(l)))=O(N)
* 块内数据关系只有两种{+1, -1}，所以一共有2^l个不同的块，块内预处理为O(2^l*l^2)=O(N)，标记每个块的类型的复杂度O(N)
* 当查询区间在块内时直接块内查询即可，如果为块间，只要2次块內和一次B上的RMQ即可，复杂度都为O(1)

因此最终预处理复杂度为O(N)，查询复杂度为O(1)

# Manacher(Find The Longest Palindromic Substring)
## 转换
回文长度存在奇数长度和偶数长度，当在原始串中每两个字符之间插入特殊字符（如#），则只有奇数长度的问题

    aba  => a#b#a
    abba => a#b#b#a
此时最长回文子串的长度为某一端到中心位置的长度
## 辅助数组
为了避免比较时边界的问题，在原始串的开始处加入另一个特殊字符（如$），最终结果如下

$C<sub>0</sub>#C<sub>1</sub>#...#C<sub>N-1</sub>\0

另外需要一个辅助数组P，P[i]表示以i为中心的最长回文串中i到该串某一端的距离（P[0]恒为0）
## 当MX>i时P[i]的下界
原始串中的最长回文串的长度则为P[i]+1

    Index = 0 1 2 3 4 5 6 7 8 9 10 11 12
    Str[] = $ a # b # a # a # b #  a  '\0'
    P[]   = 0 0 0 2 0 1 5 1 0 2 0  0
和KMP算法类似，我们需要基于之前的比较信息来避免不必要的比较，对于所有的j（j<i），找出使P[j]+j最大的下标id，MX=P[id]+id（P[j]+j表示以j为中心的最长回文串的右边界）

当P[id]+id=MX>i时，必然有id>i/2，此时i必然在一个回文串内，由于i之后的元素还未遍历，所以P[i]此时最大可取MX-i

考虑j为i关于id的对称点，则j=id-(i-id)=2*id-i，P[j]已经算出，当P[j]<MX-i时，因为对称的关系，P[i]此时最大可取的也需要变为P[j]，因此

    当MX>i时，P[i]的下界为Mininum{P[2*id-i], MX-i}
    当MX<=i时，无法获取更多信息，因此P[i]下界为0
获取下界后，逐步向两端扩充，计算出实际的P[i]
## 复杂度分析
当MX>i时

* MX-i>P[j]，实际上P[i]=P[j]，下一次的比较必然失败，因此只有一次比较
* MX-i<=P[j]，则会考虑更新MX，若MX不能更新，也只有一次比较，若MX能更新，由于MX有不递减的特性，且MX的上界也只能到N

当MX<=i时，P[i]初始值为0

* 下一次的比较失败时，只有一次比较
* 下一次的比较成功时，意味着P[i]>=1，此时MX必然可更新，同理MX的上界也是N

所以Manacher算法复杂度为O(N)
